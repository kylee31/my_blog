---
title: CS, 면접 대비 질문 정리 1일차
date: 2024-05-21
description: 주특기(React) 기술 질문 (State, Redux, 전역 상태 라이브러리, 가상 돔, useRef, useEffect)
---

**질문1.** 상태관리를 왜 할까요? 그리고 평소 state 관리는 어떻게 하시나요?

**답변1.** React에서 상태는 컴포넌트 렌더링과 관련되어 있습니다. 상태 변경이 될 때 해당 상태를 사용하는
컴포넌트의 렌더링이 발생하기 떄문에 관리가 필요합니다. 상태는 컴포넌트 내에서만 사용할 수 있으므로,
다른 컴포넌트와 공유하기 위해서는 props로 전달하거나, 전역으로 공유할 수 있도록 라이브러리를 활용하기도 합니다.
평소 state의 특성에 따라 다르게 관리하는데요, local(지역)에서 일어나는 state 관리는 useState를 활용하고,
전역으로 관리되어야 하는 상태는 라이브러리를 사용합니다.
최근 프로젝트에서는 state 변경 빈도수에 따라 전역 상태 관리 라이브러리를 다르게 적용한 경험이 있습니다.
변경 사항이 적은 사용자 정보는 상위 컴포넌트를 provider 컴포넌트를 감싸는 context api로,
비교적 변경이 많은 state인 장바구니 데이터는 zustand로 전역 상태 관리하여 다른 컴포넌트에서 불필요한 렌더링이
발생하지 않도록 적용해보았습니다.

**[Keyword]** 리렌더링, 컴포넌트, 로컬 / 지역 상태

<hr />

**질문2.** Redux가 무엇인가요, 왜 Redux를 사용하시나요?

**답변2.** Redux란 전역 상태 라이브러리입니다. Redux의 사용 목적은 여러 컴포넌트에서 사용되어야 하는 state를 공유하고,
관리하기 위해 사용됩니다. 중앙 집중 관리 형식인 Flux 패턴을 사용하여 Store에서 초기값을 설정하고 이후 액션,
디스패치 등의 개념을 활용하여 디스패치로 state의 액션을 발생시키고, 액션(상태 변화를 요청하는 명령어)을 전달하여
리듀서(함수)에서 state에 변경사항을 반영하게 됩니다.
Props로 전달하는 대신 전역 상태 라이브러리를 사용하면 해당 상태를 사용해야하는 컴포넌트에 보다 직관적으로 전달하고,
props drilling과 같은 현상을 방지할 수 있습니다. 토이 프로젝트에서 Redux를 사용하여 데이터를 관리했을 때 적용 전보다
상태 관리가 쉬워졌지만, Redux 특성 상 보일러 플레이트 코드가 많아졌다는 단점을 겪었습니다.

- Redux DevTool 활용으로 어떤 액션으로 상태가 변화하였는지 확인할 수 있습니다.
- Redux-Thunk, Redux-Saga와 같은 미들웨어를 통해 비동기 통신(로직)을 관리하여 애플리케이션의 상태 변화를 예측
  가능할 수 있습니다.

**[Keyword]** useState, 보일러 플레이트, 부모 - 자식 컴포넌트, 리렌더링

<hr />

**질문3.** Redux 말고 다른 전역 상태관리 아는 것 하나와 차이점을 말해주세요.

**답변3.** Zustand 라이브러리와의 차이점을 설명해보겠습니다. Zustand는 Redux와 동일하게 Flux 패턴으로 create로
store를 생성하고, set과 get을 활용하여 전역 상태 관리를 돕는 라이브러리입니다. 차이점으로 보일러플레이트 코드가 적고,
dispatch를 사용하여 액션을 일으킬 필요없이 hook과 같은 형태로 state와 함수를 활용할 수 있다는 점을 들 수 있습니다.
프로젝트에서 zustand를 사용할 때 Redux보다 간결하고 직관적이라는 느낌을 받았습니다.

**[Keyword]** recoil - selector, 캐싱, jotai - atom, read / write

<hr />

**질문4.** 버츄얼 돔과 리얼 돔의 차이를 설명해주세요.

**답변4.** 리얼 돔은 실제 브라우저에서 렌더링 되는 돔 트리입니다. 버츄얼 돔은 메모리에 저장되는 가벼운
리얼 돔 트리 복사본(리얼 돔을 가상화)입니다. 이전 버츄얼 돔과 비교하여 변경 사항이 생겼다면 변경이 일어난 노드만
리얼 돔에 반영됩니다. 이러한 가상 돔을 활용하게 되면 변경마다 전체 노드가 렌더링되는 리얼 돔 대신,
부분 렌더링으로 빠른 렌더링 및 성능 향상과 렌더링 최적화가 가능하다는 것이 React의 큰 특징입니다.

- React는 이전 가상 돔과 새로 리렌더링된 가상 돔을 비교합니다. 이를 위해 ‘재조정(reconciliation)’ 과정을 사용하며,
  이 과정에서 '디프 알고리즘(Diff Algorithm)-두 개의 데이터 집합 차이점 식별'을 활용하여 두 가상 돔 사이의
  차이점을 효율적으로 계산합니다.
- 가상 돔은 변경사항을 모아두었다가, 실제 돔에 한 번에 반영하게 됩니다. (가상 돔은 변경사항을 모아두었다가, 이벤트
  루프의 한 사이클에서 실제 돔에 한 번에 반영함으로써 브라우저의 렌더링 작업을 최소화하고, 빠른 UI 반응 속도를 제공)
- 반영 시점은 React가 내부적으로 관리하는 ‘배치 업데이트(batch update)’ 메커니즘에 의해 결정됩니다. 이 메커니즘은
  여러 상태 변경이 있을 때, 각각의 변경을 즉시 반영하는 대신, 효율적인 업데이트를 위해 변경사항을 모아 한꺼번에 처리합니다.

**[Keyword]** tree , 성능, 전체 / 부분 렌더링

<hr />

**질문5.** useRef에 대해 설명해주세요.

**답변5.** useRef는 컴포넌트 렌더링 사이클 동안 일관성을 유지해야 하는 값을 저장하거나, 돔 요소에 접근하여 요소의
속성이나 값을 제어하는 React Hook입니다.
두번째 상황의 사용 예시를 들자면, form 태그에서 컴포넌트가 값을 직접 제어하는 제어 컴포넌트가 되는데, useRef를 사용하게 되면
돔 노드 직접 접근하여 값을 제어하는 비제어 컴포넌트로 활용할 수 있게 됩니다. (input 값 변경 렌더링이 불필요한 상황에서도 사용)

- 자바스크립트에서는 getElementById나 querySelector를 사용하여 DOM 요소에 접근하지만, React에서는 useRef를 사용하여
  참조 객체를 생성하고, 이 객체를 원하는 DOM 요소에 연결하여 직접 접근할 수 있습니다.
- useState는 리렌더링이 필요한 값을 저장하는데에 사용하고, useRef는 리렌더링을 발생시키지 않아야 하는 값을 저장하는데 사용하는 것이 효율적입니다.
- useRef는 React의 반응형 UI 업데이트 매커니즘에 부합하지 않기 때문에, DOM 요소에 접근하거나,
  렌더링에 영향을 주지 않는 값(예: 타이머 ID, 외부 라이브러리 인스턴스 등)을 저장하는 데 사용되며,
  상태 관리에는 useState나 useReducer와 같은 다른 훅을 사용하는 것이 권장됩니다.
- useRef로 생성된 참조는 컴포넌트의 리렌더링에 영향을 받지 않습니다. 따라서 컴포넌트가 언마운트되어도 useRef에 저장된 값은
  사라지지 않고 남아 있을 수 있습니다. 이는 컴포넌트의 생명주기와 일치하지 않는 상태를 유지하게 만들며, 메모리 누수의 원인이 될 수 있습니다.

**[Keyword]** DOM, 값 유지(저장), 컴포넌트 내 접근

<hr />

**질문6.** useEffect의 실행 순서에 대해 설명해주세요.

**답변6.** useEffect는 생명 주기와 관련있는 hook입니다. useEffect 내부 함수는 컴포넌트가 언마운트 되거나, 의존 배열 state의 변경이 발생하면
호출되어 사이트 이펙트를 발생시키게 됩니다. useEffect는 브라우저 렌더링이 완료된 후, 즉 paint 과정까지 마친 뒤에 해당 사이드 이펙트를
비동기적으로 실행시킵니다. 만약 부모 컴포넌트보다 자식 컴포넌트의 useEffect가 먼저 실행됩니다.

- useEffect의 의존 배열이 비어있을 경우: 콜백 함수는 컴포넌트가 처음 마운트될 때 한 번만 실행됩니다. 그리고 컴포넌트가 언마운트될 때
  정리 함수(clean-up function)가 실행됩니다. 이는 마운트와 언마운트 시에만 부수 효과를 수행하고 싶을 때 사용됩니다.
- useEffect 의존 배열에 값이 있을 경우: 해당 값이 변경될 때마다 useEffect 내의 콜백 함수가 실행됩니다. 또한, 컴포넌트가 언마운트될 때나
  의존성 배열 내의 값이 변경되기 전에 정리 함수가 실행됩니다. 이는 특정 상태나 속성의 변화에 반응하여 부수 효과를 수행하고 싶을 때 사용됩니다.
- useLayoutEffect는 useEffect와 동일하게 생명 주기와 관련된 훅으로, 차이점은 브라우저 렌더링 과정에서 paint 과정 전에 함수 내 과정이
  동기적으로 실행된다는 점을 들 수 있습니다. 따라서 useEffect는 API 호출과 같은 비동기 작업에 적합하고, useLayoutEffect는
  레이아웃 계산, DOM 요소 조작에 적합할 수 있습니다. useLayoutEffect는 브라우저가 화면에 그리는 것을 차단(block)하기 때문에, 필요한 경우에만 사용해야 합니다.
- useEffect는 대부분의 시나리오에서 사용되며, 화면 업데이트를 차단하지 않기 때문에 성능에 더 좋은 영향을 미칩니다.
  반면, useLayoutEffect는 화면 깜빡임을 방지하거나 DOM 요소의 크기나 위치를 계산해야 할 때 사용됩니다.

**[Keyword]** 렌더링, 의존성 배열 , clean up, set up

**+** useEffect 의존 배열에 값이 있을 경우의 정리 함수

```
import React, { useState, useEffect } from 'react';

function MyComponent({ userId }) {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    // 사용자 데이터를 가져오는 함수
    function fetchUserData(id) {
      // API 호출을 통해 사용자 데이터를 가져옵니다.
    }

    // 사용자 데이터를 가져옵니다.
    fetchUserData(userId);

    // 의존성 배열에 userId가 포함되어 있으므로,
    // userId가 변경될 때마다 이전에 설정된 부수 효과를 정리합니다.
    return () => {
      // 사용자 데이터 가져오기를 취소하거나 관련 리소스를 정리하는 코드
    };
  }, [userId]); // 의존성 배열에 userId를 포함시킵니다.

  // ...
}
```

위 코드에서 useEffect는 userId가 변경될 때마다 실행됩니다. userId가 변경되면, useEffect의 콜백 함수 내에서
새로운 userId로 사용자 데이터를 가져오기 전에, 이전 userId에 대한 부수 효과를 정리하는 함수가 먼저 실행됩니다.
이는 예를 들어 API 호출을 취소하거나, 이전 사용자 데이터에 대한 구독을 해제하는 등의 작업을 포함할 수 있습니다.

**+** 자식 컴포넌트의 useEffect가 부모 컴포넌트의 useEffect보다 먼저 실행되는 이유

useEffect 훅의 실행 순서는 실제로 부모 컴포넌트와 자식 컴포넌트의 렌더링 순서와 관련이 있습니다.
일반적으로 부모 컴포넌트가 먼저 렌더링되고, 그 다음에 자식 컴포넌트가 렌더링됩니다.
그러나 useEffect는 모든 렌더링 작업이 완료된 후에 실행됩니다.

자식 컴포넌트의 useEffect가 부모 컴포넌트의 useEffect보다 먼저 실행되는 이유는 다음과 같습니다:

1. 렌더링 완료: 부모 컴포넌트가 렌더링을 시작하고, 자식 컴포넌트를 렌더링합니다. 자식 컴포넌트의 렌더링이 완료되면,
   React는 자식 컴포넌트의 useEffect를 실행합니다.
2. 부모 컴포넌트의 렌더링 완료: 자식 컴포넌트의 useEffect 실행이 끝난 후,부모 컴포넌트의 렌더링이 완료되고, 그 이후에 부모 컴포넌트의 useEffect가 실행됩니다.
   이러한 순서는 React가 컴포넌트 트리를 효율적으로 관리하고, 부수 효과(side effects)를 적절한 시점에 실행하기 위한 것입니다.
   useEffect는 DOM 업데이트가 완료된 후에 실행되므로, 자식 컴포넌트의 DOM 업데이트가 부모 컴포넌트의 DOM 업데이트보다
   먼저 완료되기 때문에 이러한 순서가 발생합니다.
