---
title: Javascript, Closuer란
date: 2024-02-26
description: Javascript에서 Closuer란 무엇인가
---

> 나의 언어대로 개념 정리하기

<hr />

먼저 실행 컨텍스트와 스코프 개념을 간단히 짚고 넘어가자면,

- 실행 컨텍스트, 코드가 실행될 때 필요한 환경 정보를 담은 객체
- 스코프, 코드에서 변수에 접근할 수 있는 범위

**클로저 Closure**란, Javascript의 고유 개념은 아니고, 함수형 프로그래밍 언어에서 공통적으로 발생하는 특성이다.
**함수가 선언될 당시의 환경(렉시컬 스코프)을 기억하여 해당 함수가 종료된 이후에도 외부 변수에 접근할 수 있도록 하는 현상**이다.
따라서 상위 실행 컨텍스트가 종료된 후에도 하위 컨텍스트가 상위 컨텍스트(변수)에 접근할 수 있다.
이는 렉시컬 환경(스코프)과 관련이 있는데, 렉시컬 환경에서는 **함수 선언 시**에 상위 스코프가 결정된다.
자바스크립트는 렉시컬 스코프를 따르므로 호출 위치와 관계없이 선언 시 결정된 상위 스코프를 기준으로 변수를 조회한다.

외부함수 스코프에서 내부함수 스코프로 접근 불가능하지만, 내부함수에서는 외부함수 스코프에서 선언된 변수에 접근 기능하다.
따라서 내부 함수는 외부함수에 선언된 변수에 접근 가능하다. 이 특성을 이용하여 데이터를 보존하고, 정보 접근 제한(캡슐화), 모듈화
하는 것이다.

자세히 따지자면 클로저는 특정 상황에서 발생하는 '현상'이고 '함수'는 이 현상이 나타나기 위한 '조건'에 해당한다.

❗ 클로저는 반환된 함수가 호출되어야 비로소 외부 변수에 접근할 수 있기 때문에, 반환된 함수를
저장하지 않거나 호출하지 않으면 클로저를 활용할 수 없습니다.

### 클로저를 만드는 형태 2가지

클로저를 구현하기 위해서는 외부 함수가 내부 함수를 외부로 전달하고, 내부 함수에서 외부 변수를 참조해야 합니다.
(여기서 외부로 전달하는 수단으로 return을 사용할 수 있는거지, 클로저에서 외부 함수가 항상 내부 함수를 반환한다고 보면 안된다.)

- 중첩 함수

```js
function outerFn() {
  let x = 10;
  // innerFn 함수는 클로저다
  return function innerFn(y) {.
    return (x = x + y);
  };
}
// 외부함수 호출은 한번만. 이제 a 변수는 innerFn 함수를 참조한다.
// 즉, 클로저를 활용하기 위해 반환된 함수 a에 저장한다.
let a = outerFn();
a(5); // 15;
```

- 전역에 선언한 변수를 박스 안에서 함수로 정의하고 전역에서 호출

```js
let globalFunc;
{
  let x = 10;
  // globalFunc 함수는 클로저다.
  globalFunc = function (y) {
    return (x = x + y);
  };
}
globalFunc(5); // 15;
```

```js
function createCounter() {
  let count = 0;

  return function () {
    let x = 10;
    ++count;
    return x + count;
  };
}

//createCounter함수는 한번 호출된 후 사라지고 counter는 내부 함수를 참조하게 된다.
let counter = createCounter();

console.log(counter()); //11
console.log(counter()); //12
console.log(counter()); //13
```

주로 비동기 작업, 정보 은닉, 콜백 함수 등의 상황에서 활용된다. 따라서 중첩 함수를 사용하여 클로저를
생성하는 것이 자바스크립트에서 일반적인 패턴이다. 그러나 중첩 함수가 아니더라도, 클로저는 다양한 형태로 구현될 수
있다. 예를 들어, 콜백 함수나 반환된 함수 등의 형태로도 클로저를 생성할 수 있다. 중첩 함수가 클로저를 생성하는
가장 일반적인 형태 중 하나이지만, 그 외에도 다양한 방식으로 클로저를 활용할 수 있다.

**+** 기술 매니저님 (useState를 통한 closuer 이해)

![](/learned/cs-rendering-3.jpg)

![](/learned/cs-rendering-4.jpg)

클로저(closure)는 함수와 그 함수가 선언된 어휘적 환경(lexical environment)의 조합입니다.
이 경우, closuer 함수는 내부에 count라는 변수를 가지고 있고, 이 함수는 또 다른 함수를 반환합니다.
반환된 함수가 호출될 때마다, count 변수는 1씩 증가합니다.

여기서 중요한 점은 count 변수가 closuer 함수의 호출이 끝난 후에도 사라지지 않고, 반환된 함수에 의해 계속 참조되고
있다는 것입니다. 이것이 클로저의 핵심적인 특징입니다. count는 closuer 함수의 지역 변수이지만, 반환된 함수가 실행될
때마다 그 값이 유지되는 것이죠.
const counter=closuer()를 호출하면, closuer 함수는 함수를 반환하고, counter는 그 반환된 함수를 참조하게 됩니다.
이후 counter()가 처음 호출될 때, count는 0에서 1로 증가하고, 결과로 1을 반환합니다.
counter()가 두 번째로 호출될 때, count는 1에서 2로 증가하고, 결과로 2를 반환합니다.

이렇게 클로저를 사용하면, 함수가 개인적인 상태를 가질 수 있고, 이 상태는 함수가 외부에서 호출될 때마다 유지됩니다.
이러한 특성 덕분에 클로저는 프로그래밍에서 매우 유용하게 사용됩니다. 예를 들어, 데이터를 숨기거나 캡슐화하는 데
사용할 수 있습니다.

<hr />

👩‍💻💬 클로저란, 함수가 선언될 당시 상위 스코프에 대한 환경을 기억하는 현상으로 상위 스코프 종료 시에도 상위 환경에
접근할 수 있게 된다. 함수가 선언될 당시 상위 스코프를 결정하는 렉시컬 스코프의 특징으로 인해 생기는 현상이다.

<hr />

### 📌 참고

- [변수의 유효범위와 클로저](https://ko.javascript.info/closure)
- [[JavaScript] 클로저(Closures)란 무엇일까?](https://hanamon.kr/javascript-%ED%81%B4%EB%A1%9C%EC%A0%80/)
