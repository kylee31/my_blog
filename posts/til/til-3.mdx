---
title: TIL 3
date: 2024-04-03
description: 알고리즘 2주차, 1일~6일
---

### 04/03

#### 스택, 큐, 덱

기본 자료구조. 파이썬 사용 시 deque 내장 라이브러리 활용해서 원형 큐 구현 가능.

- popleft로 맨 앞 요소 제거 가능

```
from collections import deque
arr=deque([1,2,3])
#큐 구현
arr.appendleft(4)
arr.popleft()
arr.append(5)
arr.pop()
#스택 구현
arr.append(6)
arr.pop()
```

예전에 알고리즘 문제를 풀 때 스택으로 해결할 수 있는 문제가 많이 나오는 것 같다고 느꼈다.
(스택은 FILO, 큐는 FIFO, 덱은 양 끝에서 IO 가능)

#### 1~6번 문제

여섯 문제 중 6번! 좋은 문제 ([백준 - 오큰수](https://www.acmicpc.net/problem/17298)) 7,8번 특히 8번은 구현이
들어간 문제로 굳이 풀지 않아도 다른 문제를 더 풀어보는 것을 추천해주셨다.

- [백준 - 오등큰수](https://www.acmicpc.net/problem/17299)
- [백준 - 스카이라인 쉬운거](https://www.acmicpc.net/problem/1863)

1~6번 문제 정리하고 추가 문제 주신거 풀어보기. 기본 문제도 구글링하면서 겨우 학습하고 푸는데ㅠㅠ 하루가 너무 부족하다ㅜㅜ..

#### nextstep

https://edu.nextstep.camp
(개발자로서 성장하기 위해 참여하면 좋은 강의들)

<hr />

### 04/04

#### 힙, 해시 테이블

- 힙(Heap)이란 트리 구조 중 하나로, 이진 트리 일종이다. 일반적인 트리와는 다르게 힙은 **부모와 자식 노드 간의
  상대적인 크기 관계에 규칙을 가지는 특별한 형태**의 이진 트리이다.
- 해시 테이블(Hash Table)은 key와 value값을 매핑된 자료 구조이다. 파이썬에서는 dictionary라는 구체적인 자료구조를 제공한다. (해시 테이블은 딕셔너리를 구현하는 데 사용되는 기술 중 하나)

**-** 최소 힙이란? 부모 노드가 자식 노드보다 작거나 같은 값을 가지며 파이썬에서 heapq 라이브러리는 최솟값을
우선순위로 하는 힙을 제공한다.

**-** 반대로 최대 힙이란, 부모 노드가 자식 노드보다 크거나 같은 값을 가지는 힙이다.

```py
import heapq #힙 라이브러리 import
```

[백준 - 카드 합체 놀이](https://www.acmicpc.net/submit/15903/76314797)

**-** 해당 문제에서 초기 계산을 위해 list의 sorted로 정렬 후 heap 계산을 진행했는데, heapq.heapify(정렬할 값)로
최소 힙 정렬이 가능하다.

❓ 해시 테이블에 값 추가, 셋팅하기
-> 추가하려는 키 정보 유무를 검사하여 값을 초기화해주거나, 값을 변경(혹은 추가)해주어야 한다.

```py
#ex. fruit, fruit개수를 5번 받아서 해당 과일의 총 개수 출력하기
table={}
for _ in range(5):
	fruit,number=input().split()
    #table에 해당 과일이 없다면 초기화해주기
    if fruit not in table:
    	table[fruit]=int(number)
    #table에 해당 과일이 있다면 value에 값 더해주기
    else:
    	table[fruit]+=int(number)
for fruit in table:
	print(fruit,table[fruit])
```

**+** 일반적인 큐는 FIFO이다. 즉, 별다른 조건없이 먼저 들어온 데이터가 나가는 구조이다. **우선순위 큐**는 들어간
순서에 상관없이 우선순위가 높은 데이터가 먼저 나오는 자료 구조로, 힙으로 구현할 수 있다.
[자료구조 - 우선순위 큐(Priority Queue)와 힙(heap)](https://chanhuiseok.github.io/posts/ds-4/)

#### 카드 정렬하기 문제

[[BOJ 1715] 카드 정렬하기 - 짱J](https://velog.io/@leeeeeyeon/BOJ-1715-%EC%B9%B4%EB%93%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0)
(이분 풀이 과정이 나의 생각 흐름과 비슷해서 붙여두었다!)
heap 라이브러리가 익숙하지 않아서 다른 힙 문제를 풀다가 이 문제를 풀면서 이해가 많이 된 것 같다.
해당 문제는 heap을 사용하여 간단하게 해결할 수 있는 문제.

-> 최소값 2개를 뽑아서(heappop) 더한 후 해당 값을 다시 넣어(heappush) 카드 뭉치 개수가 1이 될때까지 반복해주면 된다.
이를 최소 힙을 활용하여 구현했다.

#### 이력서 피드백 신청하기

너무 미뤄뒀다ㅜㅜ 피드백 주신 내용으로 참고해서 정리하고 나니까 더🙃 초라해졌지만 어쩔 수 없다..
내가 프로젝트에서 어떤 고민을 했는지를 잘 녹여내보자.

<hr />

### 04/05

#### 이분 탐색, 정렬

이분 탐색은 모든 값을 계산해보는 대신 범위를 정하여 정답이 있는 방향으로 범위를 좁혀가는 자료 구조 형태이다.
시간 복잡도를 O(logn)으로 줄일 수 있는 탐색법.

[백준 - 나무 자르기](https://www.acmicpc.net/problem/2805)

- 이중 for문 사용, O(n^2)

```py
"""
최소,최대 값을 구해서 그 범위 안에서 수를 늘려가며 잘라보면 되지 않을까?
하지만 이렇게 구현하면 예상 최대 시간 복잡도 O(n^2)..
- 최악의 경우를 생각하면, 최대 최소가 1과 1,000,000이라면 모두 찾아야 함
어떻게 줄일 수 있을까
- 이분 탐색?
"""
import sys
input=sys.stdin.readline
n, m = map(int, input().split())
tree = list(map(int, input().split()))
min_tree, max_tree = 1, max(tree)
res = 0
for i in range(max_tree, min_tree-1, -1):
    result = 0
    for t in tree:
        if t - i > 0:
            result += t - i
    if result >= m:
        res = i
        break
print(res)
```

- 이분 탐색 적용, O(logN)
  로직은 아래와 같다. 최소, 최대값을 알고 있기 때문에 중간값(최대+최소//2)을 구하여 자른 나무 합이 구해야
  하는 나무 총합과 같은지 비교, 자른 나무 합이 작아야 하면 중간 값에서 -1, 커야 하면 +1을 해주어 최소 값이
  최대 값보다 같거나 작을 동안 while문을 돌려준다.

```py
n, m = map(int, input().split())
tree = list(map(int, input().split()))
min_tree, max_tree = 1, max(tree) #범위가 1부터~이므로 0이 아닌 1로 최소값 설정

# 이분 탐색 범위 설정
left, right = min_tree, max_tree

res = 0
while left <= right:
    mid = (left + right) // 2
    total_length = 0
    # 해당 높이로 나무를 잘랐을 때 얻게 되는 나무의 길이 계산
    for t in tree:
        if t > mid:
            total_length += t - mid
    # 나무의 길이와 목표로 하는 나무의 길이 비교
    if total_length >= m:
        res = mid
        left = mid + 1  # 높이를 더 높여서 더 많이 자를 수 있도록 범위를 줄임
    else:
        right = mid - 1  # 높이를 낮춰서 더 적게 자를 수 있도록 범위를 줄임

print(res)
```

**📍 구현 로직**

1. 초기의 이분 탐색 범위 설정: 최소 높이와 최대 높이를 이분 탐색의 시작 범위로 설정합니다.
2. 이분 탐색 과정:
   중간 높이를 계산합니다.
   해당 높이로 모든 나무를 잘랐을 때 얻게 되는 나무의 길이를 계산합니다.
   계산된 나무의 길이와 목표로 하는 나무의 길이(M)를 비교합니다.
   이분 탐색의 방향을 결정하여 다음 탐색 범위를 설정합니다.
3. 이분 탐색 종료 조건: 최적의 높이를 찾을 때까지 이분 탐색을 반복합니다.

#### 추가 문제 풀이

과제로 나온 문제가 어려워서 추가 문제를 풀었다(solved에서 #,\*로 키워드와 레벨을 서치하고 가장 많이 푼 문제를 풀었다).
이분 탐색 개념을 확실히 알게 되었지만 알고리즘 문제로 조금만 변형되어도 헤맸다. 특히 4,6,7,8번은 힌트 없이는
풀 수 없는 문제라 다른 문제를 더 풀어보았다.

#### ⭐이분 탐색 mid값 정하기 (start,end)

**✔조건이 만족하는 경우의 범위를 좁혀갈 때:**

- 목표 값보다 크거나 같은 최소값을 찾는 경우, start = mid + 1과 같이 설정해 범위를 조정합니다.

- 목표 값보다 작거나 같은 최대값을 찾는 경우, end = mid - 1로 설정해 범위를 조정합니다.

**✔조건이 만족하지 않는 경우의 범위를 좁혀갈 때:**

- 목표 값보다 작아야 하는 조건에서, end = mid - 1로 설정합니다.
- 목표 값보다 커야 하는 조건에서, start = mid + 1로 설정합니다.

1. answer 글로벌 변수 선언
2. start랑 end 업데이트 할 때, 그냥 answer 변수를 계속 업데이트하기.

- start, end 값이 정답이 될 가능성이 있을 때, ans = max(ans, start) 이런식으로 값 업데이트.

3. 그리고 마지막에 answer 리턴 이런 식으로 하면 깔끔.

### 04/06

#### 복습하기

stack,queue,heap,이분탐색 관련 문제를 풀었다. 한번 풀었던 유형이라 문제를 읽고 어떤 방식을 적용해야
하는지 좀 더 잘 알 수 있었다. 잊어버리지 않게 이전에 학습했던 유형 별 문제 하나씩(아마 수월하게 풀수 있는 티어)
풀어야겠다고 생각했다.

알고리즘은 며칠만 지나도 잊어버린다😢 멘토님 말씀처럼 알고리즘 문제는 가장 최근에 제일 많이 풀어본 사람이 가장
잘할 수 있는 것 같다.

#### 멘토링

멘토님이 오늘 얻어오신 인사이트를 간단히 올려주셨는데 아직 현재 상황에 직접적으로 와닿는 부분은 없지만,
앞으로 개발 업무를 하면서 만날 수 있는 상황을 읽어볼 수 있어서 유익했다.

#### 프론트엔드 개발 업무

프론트에서는 어떤 업무를 하는지에 대해 잠깐 얘기가 나왔는데 주로 번들링 크기 개선, 테스트 코드 .. 등을 얘기하셨다.
테스트 코드는 관심이 있었지만 독학으로 하다보니 시작을 어떻게 해야 할지 몰라서 방치하고 있던 분야인데 개인
프로젝트 주차에서 확실하게 적용해봐야겠다고 느꼈다.

### 04/08

#### DFS, BFS

- DFS, 깊이 우선 탐색
- BFS, 너비 우선 탐색

✅ [DFS+BFS 필수 문제](https://www.acmicpc.net/workbook/view/1983)

#### 편한 풀이

최단 거리 등의 문제를 풀 때 BFS가 대부분 쓰이므로, BFS를 손에 익혀야겠다고 생각했다.
특히 파이썬에서 queue를 제공해주므로 훨씬 편하게 구현할 수 있다!

### 04/09

#### 문제 풀이 (테스트)

학습했거나 풀어봤던 문제(혹은 유형)가 나오면 쉽게 풀리지만, 여러 유형이 조합되는 순간 적용하는게 어려워졌다.
알고리즘을 3주만에 마스터한다는게 말도 안되는 얘기지만(24시간 하루종일하면 가능할지도?) 현재 나는 기본은 알아야 하고,
할 수 있어야 하기 때문에 더 열심히 해야겠다는 생각이 들었다.
특히 풀었던 유형이라도 이틀만 지나도 원상복귀되는 현상이 가장 힘든 것 같다..😭
유형별로 쉬운 문제를 뽑아서 하루에 하나씩 풀어야겠다.

#### 프로젝트 설계도 재작성

이력서 정리 중 Next.js 13 이후의 SSR, SSG 렌더링 방식(서버 컴포넌트, app router)을 사용해보았다는 것을 보이고 싶어서
블로그 프로젝트를 진행했다. 간단한 프로젝트였고 이력서에 작성해도 되나?라는 생각이 들때,
이력서 피드백으로 중요도가 낮은 프로젝트를 제외하는게 좋겠다는 내용을 받았다.
해당 프로젝트를 진행하며 얻었던 지식을 바탕으로 이전 프로젝트에서 잘못 설계된 컴포넌트를 리팩토링하는
것이 좋겠다는 생각이 들었다. (블로그 프로젝트로 서버 컴포넌트의 개념을 확실히 정립할 수 있어 좋았다.)
컴포넌트 구조를 재작성하여 SEO 최적화를 적용할 수 있도록 기본을 다듬는 것이 이번 리팩토링 목표이다.
