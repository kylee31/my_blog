---
title: CS, React 기술 질문 5
date: 2024-05-29
description: 주특기(React) 기술 질문 (라이프 사이클, 라이프 사이클 메소드, lazy loading/code splitting)
---

**질문1.** 라이프사이클이 의미하는 바에 대해서 설명해주세요.

**답변1.** 생명주기는 리액트의 컴포넌트가 생성되고 실행, 소멸되기까지의 과정을 의미합니다. 컴포넌트는 DOM에 생성되는
마운트, 이후 업데이트, 마지막으로 DOM에서 삭제되는 언마운트 과정을 거치며 렌더링됩니다. 이러한 라이프 사이클을 제어하고
상태를 관리하기 위해 클래스형에서는 메소드를, 함수형에서는 hook을 활용하여 코드를 작성하고 동작을 구현할 수 있습니다.

- 생성-마운트-업데이트-언마운트
- 생성 단계는 컴포넌트가 메모리에 생성되는 단계입니다. 이때 초기 상태와 Props가 설정됩니다.
- 라이프 사이클의 이해는 컴포넌트 동작을 최적화하고, 예상치 못한 버그나 문제를 방지하는 데 중요한 역할을 합니다.

**[Keyword]** 컴포넌트 생명 주기, 메모리 할당

<hr />

**질문2.** 라이프사이클 메소드에 대해 설명해주세요.

**답변2.** 라이프 사이클 메소드란, React의 클래스형 구현에서 생명주기를 다루기 위해 사용되는 함수입니다. 즉, 컴포넌트가 브라우저
상에 나타나고, 업데이트 된 후 사라질 때 호출되는 메소드입니다. 처음 DOM에 렌더링될 때 componentDidMount,
업데이트 후 호출은 componentDidUpdate, 마지막으로 DOM에서 사라질 때 componentWillUnmount 메소드를 사용하여 생명주기를
다룰 수 있습니다. 이러한 라이프사이클 메소드는 함수형에서 사용할 수 없으므로, react에서 제공하는 Hook이라는
내장함수를 통해 생명주기를 관리할 수 있습니다.

- shouldComponentUpdate : 컴포넌트가 리렌더링할지 결정, 성능 최적화에 쓰입니다.

**[Keyword]** componentDidMount, shouldComponentUpdate,componentDidUpdate componentWillUnmount 등

<hr />

**질문3.** Lazy loading과 Code splitting에 대해 아는 만큼 설명해주실 수 있을까요?

**답변3.** 레이지 로딩은 특정 리소스를 필요한 시점에 로딩하는 기법입니다. 웹 페이지 초기 로딩 시에 모든 리소스가
아니라 필요한 리소스만 다운로드받을 때 사용됩니다. React에서 image 태그 loading 속성을 통해 이미지에 도달하였을 때
로드되도록 하는 방식을 예로 들 수 있습니다. 코드 스플리팅은 단어 그대로 코드를 분리하고 쪼개는 작업으로,
이를 활용하여 필요한 부분만 로드될 수 있도록 설정할 수 있습니다. Vite의 rollup 메서드를 활용하여 chunk를 적절한
단위로 분리하거나, React.lazy 함수와 suspense컴포넌트를 활용하여 컴포넌트 코드 스플리팅 후 레이지 로딩을 적용할
수도 있습니다. 이러한 기법은 초기 번들 크기를 줄일 수 있으며 성능 최적화에 도움이 됩니다.

- React 동적 import
- lazy loading은 웹을 초기 로딩할 때 모든 리소스를 불러오지 않고 필요한 시점에 동적으로 로딩하는 기술
- code spliting은 웹의 코드를 분할하여 필요한 시점에 로딩하는 것을 의미

**[Keyword]** 필요 시점, 로딩 시점, 성능 개선, 최적화

**질문4.** Server Side Rendering, Client Side Rendering, Static Site Generation 의 장단점을 설명해주실 수 있을까요?

**답변4.** 먼저 CSR의 장단점입니다. 클라이언트 측에서 빈HTML을 받아 데이터, 자바스크립트를 적용하는 렌더링 방식으로,
초기 로딩 이후 화면 출력이 빠르다는 장점이 존재하지만, SEO 최적화에 적합하지 않습니다. SSR은 서버 측에서 HTML 생성 후
클라이언트 측에 전달하는 렌더링 방식으로, SEO 최적화에 효과적이지만, 매 렌더링마다 서버에서 HTML이 생성되므로 서버 측
부하가 발생할 수 있다는 단점이 존재합니다. 마지막으로 SSG는 빌드 시점에 HTML파일을 생성하여 렌더링하는 방식으로, 주로
정적인 컨텐츠에 활용하여 성능 최적화를 진행할 수 있습니다. 빌드 시 파일을 생성하기 때문에 실시간으로 변경된 데이터를
보여주어야 하는 상황에는 적합하지 않습니다.

**[Keyword]** SEO, 초기 로딩

**질문5.** 브라우저 렌더링 과정에 대해 아는 만큼 설명해주실 수 있을까요? 예를 들어 화면에서 DOM이 어떻게 결정되고, CSS는 어떻게 입혀지는지 등을 언급해주시면 좋습니다.

**답변5.** 브라우저 렌더링은 서버가 요청에 맞는 정적 리소스를 응답하여 반환해주면 실행됩니다. 먼저 HTML과 CSS 돔 트리가 각각 생성되는 파싱 과정을 거치며,
각각의 트리가 합쳐서 렌더 트리를 형성합니다. 렌더 트리의 각 노드의 위치를 계산하는 과정인 레이아웃을 거친 후, 화면에 CSS 스타일이 적용되는
페인트 과정으로 넘어가게 됩니다. 과정이 완료되면 여러 레이어를 합쳐 최종적으로 화면에 출력됩니다. 이후 동작이 발생하면 노드를 재계산하는
리플로우, 화면을 다시 그리는 리페인팅 과정을 거치게 됩니다.

**[Keyword]** HTML parsing, CSS parsing, Layout, Painting, Compositing

**질문6.** Event bubbling 과 capturing 을 비교하여 설명해주실 수 있을까요?

**답변6.** 두가지 모두 이벤트 전파와 관련된 동작입니다. 먼저 이벤트 버블링은 이벤트가 발생하면 발생한 DOM 요소에서 최상위 노드로
전달되는 현상입니다. 반대로 캡처링은 최상위 DOM 요소에서 이벤트가 발생한 하위 컴포넌트로 이벤트가 전달되는 현상을 뜻합니다.
기본적으로 이벤트는 버블링 방식으로 전파됩니다. 이러한 동작은 성능 최적화를 위한 동작입니다. 이벤트가 발생한 요소에서 관리하는
것이 아닌(하위 요소 모두에게 이벤트를 할당하는 것이 아니라), **이벤트 위임**으로 상위 요소에서 한번에 관리할 수 있기 때문에
성능 최적화에 도움이 됩니다.

- 예시로, 리스트의 li 요소에 이벤트가 발생한다면, 이벤트 위임을 통해 상위 요소 ul에서 이벤트 핸들러를 통해 특정 요소의
  이벤트를 관리할 수 있게 됩니다.
- 이벤트 핸들러의 세번째 인자에 true 설정 시 이벤트 캡처링 설정 가능, default는 false로 이벤트 버블링

```js
<ul id="list">
  <li id="item1">Item 1</li>
  <li id="item2">Item 2</li>
  <li id="item3">Item 3</li>
</ul>
```

**[Keyword]** 상향식 / 하향식 전파

<hr />
